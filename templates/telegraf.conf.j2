{{ ansible_managed|comment }}
[global_tags]
{% if telegraf_config__global_tags is mapping %}
{% for tag_name, tag_value in telegraf_config__global_tags.iteritems() %}
  {{ tag_name }} = {{ tag_value }}
{% endfor %}
{% endif %}
[agent]
  interval            = "{{ telegraf_config__agent__interval }}"
  round_interval      = {{ telegraf_config__agent__round_interval }}
  metric_batch_size   = {{ telegraf_config__agent__metric_batch_size }}
  metric_buffer_limit = {{ telegraf_config__agent__metric_buffer_limit }}
  collection_jitter   = "{{ telegraf_config__agent__collection_jitter }}"
  flush_interval      = "{{ telegraf_config__agent__flush_interval }}"
  flush_jitter        = "{{ telegraf_config__agent__flush_jitter }}"
  debug               = {{ telegraf_config__agent__debug }}
  quiet               = {{ telegraf_config__agent__quiet }}
  hostname            = "{{ telegraf_config__agent__hostname }}"
  omit_hostname       = {{ telegraf_config__agent__omit_hostname }}
{% if telegraf_config__outputs__influxdb__enabled %}
[[outputs.influxdb]]
  urls                 = ["{{ telegraf_config__outputs__influxdb__urls|join('","') }}"] # required
  database             = "{{ telegraf_config__outputs__influxdb__database }}" # required
  precision            = "{{ telegraf_config__outputs__influxdb__precision }}"
  retention_policy     = "{{ telegraf_config__outputs__influxdb__retention_policy }}"
  write_consistency    = "{{ telegraf_config__outputs__influxdb__write_consistency }}"
  timeout              = "{{ telegraf_config__outputs__influxdb__timeout }}"
{% if telegraf_config__outputs__influxdb__auth %}
  username             = "{{ telegraf_config__outputs__influxdb__username }}"
  password             = "{{ telegraf_config__outputs__influxdb__password }}"
{% endif %}
  user_agent           = "{{ telegraf_config__outputs__influxdb__user_agent }}"
  udp_payload          = {{ telegraf_config__outputs__influxdb__udp_payload }}
{% if telegraf_config__outputs__influxdb__ssl %}
  ssl_ca               = "{{ telegraf_config__outputs__influxdb__ssl_ca }}"
  ssl_cert             = "{{ telegraf_config__outputs__influxdb__ssl_cert }}"
  ssl_key              = "{{ telegraf_config__outputs__influxdb__ssl_key }}"
  insecure_skip_verify = {{ telegraf_config__outputs__influxdb__insecure_skip_verify }}
{% endif %}
{% endif %}
{% if telegraf_config__outputs__amon__enabled %}
[[outputs.amon]]
  server_key    = "{{ telegraf_config__outputs__amon__server_key }}" # required.
  amon_instance = "{{ telegraf_config__outputs__amon__amon_instance }}" # required
  timeout       = "{{ telegraf_config__outputs__amon__timeout }}"
{% endif %}

{% if telegraf_config__outputs__amqp__enabled %}
[[outputs.amqp]]
  url                  = "{{ telegraf_config__outputs__amqp__url }}"
  exchange             = "{{ telegraf_config__outputs__amqp__exchange }}"
  auth_method          = "{{ telegraf_config__outputs__amqp__auth_method }}"
  routing_tag          = "{{ telegraf_config__outputs__amqp__routing_tag }}"
  retention_policy     = "{{ telegraf_config__outputs__amqp__retention_policy }}"
  database             = "{{ telegraf_config__outputs__amqp__database }}"
  precision            = "{{ telegraf_config__outputs__amqp__precision }}"
{% if telegraf_config__outputs__amqp__ssl_enabled %}
  ssl_ca               = "{{ telegraf_config__outputs__amqp__ssl_ca }}"
  ssl_cert             = "{{ telegraf_config__outputs__amqp__ssl_cert }}"
  ssl_key              = "{{ telegraf_config__outputs__amqp__ssl_key }}"
  insecure_skip_verify = {{ telegraf_config__outputs__amqp__insecure_skip_verify }}
{% endif %}
  data_format          = "{{ telegraf_config__outputs__amqp__data_format }}"
{% endif %}
{#
# # Configuration for AWS CloudWatch output.
# [[outputs.cloudwatch]]
#   ## Amazon REGION
#   region = 'us-east-1'
# 
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order
#   ## 1) explicit credentials from 'access_key' and 'secret_key'
#   ## 2) environment variables
#   ## 3) shared credentials file
#   ## 4) EC2 Instance Profile
#   #access_key = ""
#   #secret_key = ""
# 
#   ## Namespace for the CloudWatch MetricDatums
#   namespace = 'InfluxData/Telegraf'
#}
{#
# # Configuration for DataDog API to send metrics to.
# [[outputs.datadog]]
#   ## Datadog API key
#   apikey = "my-secret-key" # required.
# 
#   ## Connection timeout.
#   # timeout = "5s"
#}
{#
# # Send telegraf metrics to file(s)
# [[outputs.file]]
#   ## Files to write to, "stdout" is a specially handled file.
#   files = ["stdout", "/tmp/metrics.out"]
# 
#   ## Data format to output.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"
#}
{#
# # Configuration for Graphite server to send metrics to
# [[outputs.graphite]]
#   ## TCP endpoint for your graphite instance.
#   servers = ["localhost:2003"]
#   ## Prefix metrics name
#   prefix = ""
#   ## Graphite output template
#   ## see https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   template = "host.tags.measurement.field"
#   ## timeout in seconds for the write connection to graphite
#   timeout = 2
#}
{#
# # Configuration for sending metrics to an Instrumental project
# [[outputs.instrumental]]
#   ## Project API Token (required)
#   api_token = "API Token" # required
#   ## Prefix the metrics with a given name
#   prefix = ""
#   ## Stats output template (Graphite formatting)
#   ## see https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md#graphite
#   template = "host.tags.measurement.field"
#   ## Timeout in seconds to connect
#   timeout = "2s"
#   ## Display Communcation to Instrumental
#   debug = false
#}
{#
# # Configuration for the Kafka server to send metrics to
# [[outputs.kafka]]
#   ## URLs of kafka brokers
#   brokers = ["localhost:9092"]
#   ## Kafka topic for producer messages
#   topic = "telegraf"
#   ## Telegraf tag to use as a routing key
#   ##  ie, if this tag exists, it's value will be used as the routing key
#   routing_tag = "host"
# 
#   ## CompressionCodec represents the various compression codecs recognized by
#   ## Kafka in messages.
#   ##  0 : No compression
#   ##  1 : Gzip compression
#   ##  2 : Snappy compression
#   compression_codec = 0
# 
#   ##  RequiredAcks is used in Produce Requests to tell the broker how many
#   ##  replica acknowledgements it must see before responding
#   ##   0 : the producer never waits for an acknowledgement from the broker.
#   ##       This option provides the lowest latency but the weakest durability
#   ##       guarantees (some data will be lost when a server fails).
#   ##   1 : the producer gets an acknowledgement after the leader replica has
#   ##       received the data. This option provides better durability as the
#   ##       client waits until the server acknowledges the request as successful
#   ##       (only messages that were written to the now-dead leader but not yet
#   ##       replicated will be lost).
#   ##   -1: the producer gets an acknowledgement after all in-sync replicas have
#   ##       received the data. This option provides the best durability, we
#   ##       guarantee that no messages will be lost as long as at least one in
#   ##       sync replica remains.
#   required_acks = -1
# 
#   ##  The total number of times to retry sending a message
#   max_retry = 3
# 
#   ## Optional SSL Config
#   # ssl_ca = "/etc/telegraf/ca.pem"
#   # ssl_cert = "/etc/telegraf/cert.pem"
#   # ssl_key = "/etc/telegraf/key.pem"
#   ## Use SSL but skip chain & host verification
#   # insecure_skip_verify = false
# 
#   ## Data format to output.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"
#}
{#
# # Configuration for the AWS Kinesis output.
# [[outputs.kinesis]]
#   ## Amazon REGION of kinesis endpoint.
#   region = "ap-southeast-2"
# 
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order
#   ## 1) explicit credentials from 'access_key' and 'secret_key'
#   ## 2) environment variables
#   ## 3) shared credentials file
#   ## 4) EC2 Instance Profile
#   #access_key = ""
#   #secret_key = ""
# 
#   ## Kinesis StreamName must exist prior to starting telegraf.
#   streamname = "StreamName"
#   ## PartitionKey as used for sharding data.
#   partitionkey = "PartitionKey"
#   ## format of the Data payload in the kinesis PutRecord, supported
#   ## String and Custom.
#   format = "string"
#   ## debug will show upstream aws messages.
#   debug = false
#}
{#
# # Configuration for Librato API to send metrics to.
# [[outputs.librato]]
#   ## Librator API Docs
#   ## http://dev.librato.com/v1/metrics-authentication
#   ## Librato API user
#   api_user = "telegraf@influxdb.com" # required.
#   ## Librato API token
#   api_token = "my-secret-token" # required.
#   ## Debug
#   # debug = false
#   ## Tag Field to populate source attribute (optional)
#   ## This is typically the _hostname_ from which the metric was obtained.
#   source_tag = "host"
#   ## Connection timeout.
#   # timeout = "5s"
#   ## Output Name Template (same as graphite buckets)
#   ## see https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md#graphite
#   template = "host.tags.measurement.field"
#}
{#
# # Configuration for MQTT server to send metrics to
# [[outputs.mqtt]]
#   servers = ["localhost:1883"] # required.
# 
#   ## MQTT outputs send metrics to this topic format
#   ##    "<topic_prefix>/<hostname>/<pluginname>/"
#   ##   ex: prefix/web01.example.com/mem
#   topic_prefix = "telegraf"
# 
#   ## username and password to connect MQTT server.
#   # username = "telegraf"
#   # password = "metricsmetricsmetricsmetrics"
# 
#   ## Optional SSL Config
#   # ssl_ca = "/etc/telegraf/ca.pem"
#   # ssl_cert = "/etc/telegraf/cert.pem"
#   # ssl_key = "/etc/telegraf/key.pem"
#   ## Use SSL but skip chain & host verification
#   # insecure_skip_verify = false
# 
#   ## Data format to output.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"
#}
{#
# # Send telegraf measurements to NSQD
# [[outputs.nsq]]
#   ## Location of nsqd instance listening on TCP
#   server = "localhost:4150"
#   ## NSQ topic for producer messages
#   topic = "telegraf"
# 
#   ## Data format to output.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"
#}
{#
# # Configuration for OpenTSDB server to send metrics to
# [[outputs.opentsdb]]
#   ## prefix for metrics keys
#   prefix = "my.specific.prefix."
# 
#   ## Telnet Mode ##
#   ## DNS name of the OpenTSDB server in telnet mode
#   host = "opentsdb.example.com"
# 
#   ## Port of the OpenTSDB server in telnet mode
#   port = 4242
# 
#   ## Debug true - Prints OpenTSDB communication
#   debug = false
#}
{#
# # Configuration for the Prometheus client to spawn
# [[outputs.prometheus_client]]
#   ## Address to listen on
#   # listen = ":9126"
#}
{#
# # Configuration for the Riemann server to send metrics to
# [[outputs.riemann]]
#   ## URL of server
#   url = "localhost:5555"
#   ## transport protocol to use either tcp or udp
#   transport = "tcp"
#   ## separator to use between input name and field name in Riemann service name
#   separator = " "
#}
{% if telegraf_config__inputs__cpu__enabled %}
[[inputs.cpu]]
  percpu    = {{ telegraf_config__inputs__cpu__percpu }}
  totalcpu  = {{ telegraf_config__inputs__cpu__totalcpu }}
  fielddrop = ["{{ telegraf_config__inputs__cpu__fielddrop|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__disk__enabled %}
[[inputs.disk]]
{% if telegraf_config__inputs__disk__mount_points|length %}
  mount_points = ["{{ telegraf_config__inputs__disk__mount_points|join('","') }}"]
{% endif %}
  ignore_fs    = ["{{ telegraf_config__inputs__disk__ignore_fs|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__diskio__enabled %}
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
{% if telegraf_config__inputs__diskio__devices|length %}
  devices = ["{{ telegraf_config__inputs__diskio__devices|join('","') }}"]
{% endif %}
  skip_serial_number = {{ telegraf_config__inputs__diskio__skip_serial_number }}
{% endif %}
{% if telegraf_config__inputs__kernel__enabled %}
[[inputs.kernel]]
{% endif %}
{% if telegraf_config__inputs__mem__enabled %}
[[inputs.mem]]
{% endif %}
{% if telegraf_config__inputs__processes__enabled %}
[[inputs.processes]]
{% endif %}
{% if telegraf_config__inputs__swap__enabled %}
[[inputs.swap]]
{% endif %}
{% if telegraf_config__inputs__system__enabled %}
[[inputs.system]]
{% endif %}
{% if telegraf_config__inputs__aerospike__enabled %}
[[inputs.aerospike]]
  servers = ["{{ telegraf_config__inputs__aerospike__servers|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__apache__enabled %}
[[inputs.apache]]
  urls = ["{{ telegraf_config__inputs__apache__urls|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__bcache__enabled %}
[[inputs.bcache]]
  bcachePath = "{{ telegraf_config__inputs__bcache__bcachePath }}"
  bcacheDevs = ["{{ telegraf_config__inputs__bcache__bcacheDevs|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__cassandra__enabled %}
[[inputs.cassandra]]
  context = "{{ telegraf_config__inputs__cassandra__context }}"
  servers = ["{{ telegraf_config__inputs__cassandra__servers|join('","') }}"]
  metrics = [
{% for metric in telegraf_config__inputs__cassandra__metrics %}
    "{{ metric }}",
{% endfor %}
  ]
{% endif %}
{% if telegraf_config__inputs__ceph__enabled %}
[[inputs.ceph]]
  ceph_binary   = "{{ telegraf_config__inputs__ceph__ceph_binary }}"
  socket_dir    = "{{ telegraf_config__inputs__ceph__socket_dir }}"
  mon_prefix    = "{{ telegraf_config__inputs__ceph__mon_prefix }}"
  osd_prefix    = "{{ telegraf_config__inputs__ceph__osd_prefix }}"
  socket_suffix = "{{ telegraf_config__inputs__ceph__socket_suffix }}"
{% endif %}
{% if telegraf_config__inputs__cloudwatch__enabled %}
[[inputs.cloudwatch]]
  region     = '{{ telegraf_config__inputs__cloudwatch__region }}'
{% if telegraf_config__inputs__cloudwatch__access_key %}
  access_key = "{{ telegraf_config__inputs__cloudwatch__access_key }}"
{% endif %}
{% if telegraf_config__inputs__cloudwatch__secret_key %}
  secret_key = "{{ telegraf_config__inputs__cloudwatch__secret_key }}"
{% endif %}
  period     = '{{ telegraf_config__inputs__cloudwatch__period }}'
  delay      = '{{ telegraf_config__inputs__cloudwatch__delay }}'
  interval   = '{{ telegraf_config__inputs__cloudwatch__interval }}'
  namespace  = '{{ telegraf_config__inputs__cloudwatch__namespace }}'
{% if telegraf_config__inputs__cloudwatch__metrics__enabled %}
  [[inputs.cloudwatch.metrics]]
    names = ["{{ telegraf_config__inputs__cloudwatch__metrics__names|join('","') }}"]
{% if telegraf_config__inputs__cloudwatch__metrics__dimensions__enabled %}
    [[inputs.cloudwatch.metrics.dimensions]]
      name  = '{{ telegraf_config__inputs__cloudwatch__metrics__dimensions__name }}'
      value = '{{ telegraf_config__inputs__cloudwatch__metrics__dimensions__value }}'
{% endif %}
{% endif %}
{% endif %}
{% if telegraf_config__inputs__couchbase__enabled %}
[[inputs.couchbase]]
  servers = ["{{ telegraf_config__inputs__couchbase__servers|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__couchdb__enabled %}
[[inputs.couchdb]]
  hosts = ["{{ telegraf_config__inputs__couchdb__hosts|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__disque__enabled %}
[[inputs.disque]]
  servers = ["{{ telegraf_config__inputs__disque__servers|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__dns_query__enabled %}
[[inputs.dns_query]]
  servers     = ["{{ telegraf_config__inputs__dns_query__servers|join('","') }}"] # required
  domains     = ["{{ telegraf_config__inputs__dns_query__domains|join('","') }}"] # optional
  record_type = "{{ telegraf_config__inputs__dns_query__record_type }}" # optional
  port        = {{ telegraf_config__inputs__dns_query__port }} # optional
  timeout     = {{ telegraf_config__inputs__dns_query__timeout }} # optional
{% endif %}
{% if telegraf_config__inputs__docker__enabled %}
[[inputs.docker]]
  endpoint        = "{{ telegraf_config__inputs__docker__endpoint }}"
  container_names = [
{% if telegraf_config__inputs__docker__container_name %}
        "{{ telegraf_config__inputs__docker__container_name|join('","') }}"
{% endif %}
  ]
  timeout         = "{{ telegraf_config__inputs__docker__timepoint }}"
{% endif %}
{% if telegraf_config__inputs__dovecot__enabled %}
[[inputs.dovecot]]
  servers = ["{{ telegraf_config__inputs__dovecot__servers|join('","') }}"]
  type    = "{{ telegraf_config__inputs__dovecot__type }}"
  filters = ["{{ telegraf_config__inputs__dovecot__ip|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__elasticsearch__enabled %}
[[inputs.elasticsearch]]
  servers        = ["{{ telegraf_config__inputs__elasticsearch__servers|join('","') }}"]
  local          = {{ telegraf_config__inputs__elasticsearch__local }}
  cluster_health = {{ telegraf_config__inputs__elasticsearch__cluster_health }}
{% endif %}
{% if telegraf_config__inputs__exec__enabled %}
[[inputs.exec]]
  commands    = ["{{ telegraf_config__inputs__exec__commands|join('","') }}"]
  timeout     = "{{ telegraf_config__inputs__exec__timeout }}"
  name_suffix = "{{ telegraf_config__inputs__exec__name_suffix }}"
  data_format = "{{ telegraf_config__inputs__exec__data_format }}"
{% endif %}
{% if telegraf_config__inputs__filestat__enabled %}
[[inputs.filestat]]
  files = ["{{ telegraf_config__inputs__filestat__files|join('","') }}"]
  md5   = {{ telegraf_config__inputs__filestat__md5 }}
{% endif %}
{% if telegraf_config__inputs__haproxy__enabled %}
[[inputs.haproxy]]
  servers = ["{{ telegraf_config__inputs__haproxy__servers|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__http_response__enabled %}
[[inputs.http_response]]
  address          = "{{ telegraf_config__inputs__http_response__address }}"
  response_timeout = "{{ telegraf_config__inputs__http_response__response_timeout }}"
  method           = "{{ telegraf_config__inputs__http_response__method }}"
  follow_redirects = {{ telegraf_config__inputs__http_response__follow_redirects }}
{% if telegraf_config__inputs__http_response__headers__enabled %}
  [inputs.http_response.headers]
    Host = "{{ telegraf_config__inputs__http_response__headers__host }}"
{% if telegraf_config__inputs__http_response__headers__body %}
    body = '''
    {{ telegraf_config__inputs__http_response__headers__body }}
    '''
{% endif %}
{% endif %}
{% endif %}
{% if telegraf_config__inputs__httpjson__enabled %}
[[inputs.httpjson]]
  name    = "{{ telegraf_config__inputs__httpjson__name }}"
  servers = [
{% for server in telegraf_config__inputs__httpjson__servers %}
    "{{ server }}",
{% endfor %}
  ]
  method  = "{{ telegraf_config__inputs__httpjson__method }}"

  ## List of tag names to extract from top-level of JSON server response
  # tag_keys = [
  #   "my_tag_1",
  #   "my_tag_2"
  # ]

  ## HTTP parameters (all values must be strings)
  [inputs.httpjson.parameters]
    event_type = "cpu_spike"
    threshold = "0.75"

  ## HTTP Header parameters (all values must be strings)
  # [inputs.httpjson.headers]
  #   X-Auth-Token = "my-xauth-token"
  #   apiVersion = "v1"

  ## Optional SSL Config
  # ssl_ca = "/etc/telegraf/ca.pem"
  # ssl_cert = "/etc/telegraf/cert.pem"
  # ssl_key = "/etc/telegraf/key.pem"
  ## Use SSL but skip chain & host verification
  # insecure_skip_verify = false
{% endif %}
{#
# # Read InfluxDB-formatted JSON metrics from one or more HTTP endpoints
# [[inputs.influxdb]]
#   ## Works with InfluxDB debug endpoints out of the box,
#   ## but other services can use this format too.
#   ## See the influxdb plugin's README for more details.
# 
#   ## Multiple URLs from which to read InfluxDB-formatted JSON
#   urls = [
#     "http://localhost:8086/debug/vars"
#   ]
#}
{#
# # Read metrics from one or many bare metal servers
# [[inputs.ipmi_sensor]]
#   ## specify servers via a url matching:
#   ##  [username[:password]@][protocol[(address)]]
#   ##  e.g.
#   ##    root:passwd@lan(127.0.0.1)
#   ##
#   servers = ["USERID:PASSW0RD@lan(192.168.1.1)"]
#}
{#
# # Read JMX metrics through Jolokia
# [[inputs.jolokia]]
#   ## This is the context root used to compose the jolokia url
#   context = "/jolokia"
# 
#   ## This specifies the mode used
#   # mode = "proxy"
#   #
#   ## When in proxy mode this section is used to specify further
#   ## proxy address configurations.
#   ## Remember to change host address to fit your environment.
#   # [inputs.jolokia.proxy]
#   #   host = "127.0.0.1"
#   #   port = "8080"
# 
# 
#   ## List of servers exposing jolokia read service
#   [[inputs.jolokia.servers]]
#     name = "as-server-01"
#     host = "127.0.0.1"
#     port = "8080"
#     # username = "myuser"
#     # password = "mypassword"
# 
#   ## List of metrics collected on above servers
#   ## Each metric consists in a name, a jmx path and either
#   ## a pass or drop slice attribute.
#   ## This collect all heap memory usage metrics.
#   [[inputs.jolokia.metrics]]
#     name = "heap_memory_usage"
#     mbean  = "java.lang:type=Memory"
#     attribute = "HeapMemoryUsage"
# 
#   ## This collect thread counts metrics.
#   [[inputs.jolokia.metrics]]
#     name = "thread_count"
#     mbean  = "java.lang:type=Threading"
#     attribute = "TotalStartedThreadCount,ThreadCount,DaemonThreadCount,PeakThreadCount"
# 
#   ## This collect number of class loaded/unloaded counts metrics.
#   [[inputs.jolokia.metrics]]
#     name = "class_count"
#     mbean  = "java.lang:type=ClassLoading"
#     attribute = "LoadedClassCount,UnloadedClassCount,TotalLoadedClassCount"
#}
{#
# # Read metrics from a LeoFS Server via SNMP
# [[inputs.leofs]]
#   ## An array of URI to gather stats about LeoFS.
#   ## Specify an ip or hostname with port. ie 127.0.0.1:4020
#   servers = ["127.0.0.1:4021"]
#}
{#
# # Read metrics from local Lustre service on OST, MDS
# [[inputs.lustre2]]
#   ## An array of /proc globs to search for Lustre stats
#   ## If not specified, the default will work on Lustre 2.5.x
#   ##
#   # ost_procfiles = [
#   #   "/proc/fs/lustre/obdfilter/*/stats",
#   #   "/proc/fs/lustre/osd-ldiskfs/*/stats",
#   #   "/proc/fs/lustre/obdfilter/*/job_stats",
#   # ]
#   # mds_procfiles = [
#   #   "/proc/fs/lustre/mdt/*/md_stats",
#   #   "/proc/fs/lustre/mdt/*/job_stats",
#   # ]
#}
{#
# # Gathers metrics from the /3.0/reports MailChimp API
# [[inputs.mailchimp]]
#   ## MailChimp API key
#   ## get from https://admin.mailchimp.com/account/api/
#   api_key = "" # required
#   ## Reports for campaigns sent more than days_old ago will not be collected.
#   ## 0 means collect all.
#   days_old = 0
#   ## Campaign ID to get, if empty gets all campaigns, this option overrides days_old
#   # campaign_id = ""
#}
{% if telegraf_config__inputs__memcached__enabled %}
[[inputs.memcached]]
{% if telegraf_config__inputs__memcached__servers|length %}
  servers      = ["{{ telegraf_config__inputs__memcached__servers|join('","') }}"]
{% endif %}
{% if telegraf_config__inputs__memcached__unix_sockets|length %}
  unix_sockets = ["{{ telegraf_config__inputs__memcached__unix_sockets|join('","') }}"]
{% endif %}
{% endif %}
{#
# # Telegraf plugin for gathering metrics from N Mesos masters
# [[inputs.mesos]]
#   # Timeout, in ms.
#   timeout = 100
#   # A list of Mesos masters, default value is localhost:5050.
#   masters = ["localhost:5050"]
#   # Metrics groups to be collected, by default, all enabled.
#   master_collections = [
#     "resources",
#     "master",
#     "system",
#     "slaves",
#     "frameworks",
#     "messages",
#     "evqueue",
#     "registrar",
#   ]
#}
{#
# # Read metrics from one or many MongoDB servers
# [[inputs.mongodb]]
#   ## An array of URI to gather stats about. Specify an ip or hostname
#   ## with optional port add password. ie,
#   ##   mongodb://user:auth_key@10.10.3.30:27017,
#   ##   mongodb://10.10.3.33:18832,
#   ##   10.0.0.1:10000, etc.
#   servers = ["127.0.0.1:27017"]
#}
{% if telegraf_config__inputs__mysql__enabled %}
[[inputs.mysql]]
  servers                                   = ["{{ telegraf_config__inputs__mysql__servers|join('","') }}"]
  perf_events_statements_digest_text_limit  = {{ telegraf_config__inputs__mysql__perf_events_statements_digest_text_limit }}
  perf_events_statements_limit              = {{ telegraf_config__inputs__mysql__perf_events_statements_limit }}
  perf_events_statements_time_limit         = {{ telegraf_config__inputs__mysql__perf_events_statements_time_limit }}
  table_schema_databases                    = [
{% if telegraf_config__inputs__mysql__table_schema_databases|length %}
  "{{ telegraf_config__inputs__mysql__table_schema_databases|join('","') }}"
{% endif %}
  ]
  gather_table_schema                       = {{ telegraf_config__inputs__mysql__gather_table_schema }}
  gather_process_list                       = {{ telegraf_config__inputs__mysql__gather_process_list }}
  gather_info_schema_auto_inc               = {{ telegraf_config__inputs__mysql__gather_info_schema_auto_inc }}
  gather_slave_status                       = {{ telegraf_config__inputs__mysql__gather_slave_status }}
  gather_binary_logs                        = {{ telegraf_config__inputs__mysql__gather_binary_logs }}
  gather_table_io_waits                     = {{ telegraf_config__inputs__mysql__gather_table_io_waits }}
  gather_table_lock_waits                   = {{ telegraf_config__inputs__mysql__gather_table_lock_waits }}
  gather_index_io_waits                     = {{ telegraf_config__inputs__mysql__gather_index_io_waits }}
  gather_event_waits                        = {{ telegraf_config__inputs__mysql__gather_event_waits }}
  gather_file_events_stats                  = {{ telegraf_config__inputs__mysql__gather_file_events_stats }}
  gather_perf_events_statements             = {{ telegraf_config__inputs__mysql__gather_perf_events_statements }}
  interval_slow                             = "{{ telegraf_config__inputs__mysql__interval_slow }}"
{% endif %}
{#
# [[inputs.net]]
#   ## By default, telegraf gathers stats from any up interface (excluding loopback)
#   ## Setting interfaces will tell it to gather these explicit interfaces,
#   ## regardless of status.
#   ##
#   # interfaces = ["eth0"]
#}
{#
# # TCP or UDP 'ping' given url and collect response time in seconds
# [[inputs.net_response]]
#   ## Protocol, must be "tcp" or "udp"
#   protocol = "tcp"
#   ## Server address (default localhost)
#   address = "github.com:80"
#   ## Set timeout
#   timeout = "1s"
# 
#   ## Optional string sent to the server
#   # send = "ssh"
#   ## Optional expected string in answer
#   # expect = "ssh"
#   ## Set read timeout (only used if expecting a response)
#   read_timeout = "1s"
#}
{#
# # Read TCP metrics such as established, time wait and sockets counts.
# [[inputs.netstat]]
#   # no configuration
#}
{#
{% if telegraf_config__inputs__nginx__enabled %}
[[inputs.nginx]]
  urls = ["{{ telegraf_config__inputs__nginx__urls|join('","') }}"]
{% endif %}
#}
{#
# # Read NSQ topic and channel statistics.
# [[inputs.nsq]]
#   ## An array of NSQD HTTP API endpoints
#   endpoints = ["http://localhost:4151"]
#}
{#
# # Collect kernel snmp counters and network interface statistics
# [[inputs.nstat]]
#   ## file paths for proc files. If empty default paths will be used:
#   ##    /proc/net/netstat, /proc/net/snmp, /proc/net/snmp6
#   ## These can also be overridden with env variables, see README.
#   proc_net_netstat = ""
#   proc_net_snmp    = ""
#   proc_net_snmp6   = ""
#   ## dump metrics with 0 values too
#   dump_zeros       = true
#}
{#
# # Get standard NTP query metrics, requires ntpq executable.
# [[inputs.ntpq]]
#   ## If false, set the -n ntpq flag. Can reduce metric gather time.
#   dns_lookup = true
#}
{#
# # Read metrics of passenger using passenger-status
# [[inputs.passenger]]
#   ## Path of passenger-status.
#   ##
#   ## Plugin gather metric via parsing XML output of passenger-status
#   ## More information about the tool:
#   ##   https://www.phusionpassenger.com/library/admin/apache/overall_status_report.html
#   ##
#   ## If no path is specified, then the plugin simply execute passenger-status
#   ## hopefully it can be found in your PATH
#   command = "passenger-status -v --show=xml"
#}
{#
{% if telegraf_config__inputs__phpfpm__enabled %}
[[inputs.phpfpm]]
  urls = ["{{ telegraf_config__inputs__phpfpm__urls|join('","') }}"]
{% endif %}
#}
{#
# # Ping given url(s) and return statistics
# [[inputs.ping]]
#   ## NOTE: this plugin forks the ping command. You may need to set capabilities
#   ## via setcap cap_net_raw+p /bin/ping
#   #
#   ## urls to ping
#   urls = ["www.google.com"] # required
#   ## number of pings to send per collection (ping -c <COUNT>)
#   count = 1 # required
#   ## interval, in s, at which to ping. 0 == default (ping -i <PING_INTERVAL>)
#   ping_interval = 0.0
#   ## ping timeout, in s. 0 == no timeout (ping -W <TIMEOUT>)
#   timeout = 1.0
#   ## interface to send ping from (ping -I <INTERFACE>)
#   interface = ""
#}
{#
# # Read metrics from one or many postgresql servers
# [[inputs.postgresql]]
#   ## specify address via a url matching:
#   ##   postgres://[pqgotest[:password]]@localhost[/dbname]\
#   ##       ?sslmode=[disable|verify-ca|verify-full]
#   ## or a simple string:
#   ##   host=localhost user=pqotest password=... sslmode=... dbname=app_production
#   ##
#   ## All connection parameters are optional.
#   ##
#   ## Without the dbname parameter, the driver will default to a database
#   ## with the same name as the user. This dbname is just for instantiating a
#   ## connection with the server and doesn't restrict the databases we are trying
#   ## to grab metrics for.
#   ##
#   address = "host=localhost user=postgres sslmode=disable"
# 
#   ## A list of databases to pull metrics about. If not specified, metrics for all
#   ## databases are gathered.
#   # databases = ["app_production", "testing"]
#}
{#
# # Read metrics from one or many postgresql servers
# [[inputs.postgresql_extensible]]
#   ## specify address via a url matching:
#   ##   postgres://[pqgotest[:password]]@localhost[/dbname]\
#   ##       ?sslmode=[disable|verify-ca|verify-full]
#   ## or a simple string:
#   ##   host=localhost user=pqotest password=... sslmode=... dbname=app_production
#   #
#   ## All connection parameters are optional.  #
#   ## Without the dbname parameter, the driver will default to a database
#   ## with the same name as the user. This dbname is just for instantiating a
#   ## connection with the server and doesn't restrict the databases we are trying
#   ## to grab metrics for.
#   #
#   address = "host=localhost user=postgres sslmode=disable"
#   ## A list of databases to pull metrics about. If not specified, metrics for all
#   ## databases are gathered.
#   ## databases = ["app_production", "testing"]
#   #
#   # outputaddress = "db01"
#   ## A custom name for the database that will be used as the "server" tag in the
#   ## measurement output. If not specified, a default one generated from
#   ## the connection address is used.
#   #
#   ## Define the toml config where the sql queries are stored
#   ## New queries can be added, if the withdbname is set to true and there is no
#   ## databases defined in the 'databases field', the sql query is ended by a
#   ## 'is not null' in order to make the query succeed.
#   ## Example :
#   ## The sqlquery : "SELECT * FROM pg_stat_database where datname" become
#   ## "SELECT * FROM pg_stat_database where datname IN ('postgres', 'pgbench')"
#   ## because the databases variable was set to ['postgres', 'pgbench' ] and the
#   ## withdbname was true. Be careful that if the withdbname is set to false you
#   ## don't have to define the where clause (aka with the dbname) the tagvalue
#   ## field is used to define custom tags (separated by commas)
#   ## The optional "measurement" value can be used to override the default
#   ## output measurement name ("postgresql").
#   #
#   ## Structure :
#   ## [[inputs.postgresql_extensible.query]]
#   ##   sqlquery string
#   ##   version string
#   ##   withdbname boolean
#   ##   tagvalue string (comma separated)
#   ##   measurement string
#   [[inputs.postgresql_extensible.query]]
#     sqlquery="SELECT * FROM pg_stat_database"
#     version=901
#     withdbname=false
#     tagvalue=""
#     measurement=""
#   [[inputs.postgresql_extensible.query]]
#     sqlquery="SELECT * FROM pg_stat_bgwriter"
#     version=901
#     withdbname=false
#     tagvalue="postgresql.stats"
#}
{#
# # Read metrics from one or many PowerDNS servers
# [[inputs.powerdns]]
#   ## An array of sockets to gather stats about.
#   ## Specify a path to unix socket.
#   unix_sockets = ["/var/run/pdns.controlsocket"]
#}
{#
# # Monitor process cpu and memory usage
# [[inputs.procstat]]
#   ## Must specify one of: pid_file, exe, or pattern
#   ## PID file to monitor process
#   pid_file = "/var/run/nginx.pid"
#   ## executable name (ie, pgrep <exe>)
#   # exe = "nginx"
#   ## pattern as argument for pgrep (ie, pgrep -f <pattern>)
#   # pattern = "nginx"
#   ## user as argument for pgrep (ie, pgrep -u <user>)
#   # user = "nginx"
# 
#   ## override for process_name
#   ## This is optional; default is sourced from /proc/<pid>/status
#   # process_name = "bar"
#   ## Field name prefix
#   prefix = ""
#   ## comment this out if you want raw cpu_time stats
#   fielddrop = ["cpu_time_*"]
#}
{#
# # Read metrics from one or many prometheus clients
# [[inputs.prometheus]]
#   ## An array of urls to scrape metrics from.
#   urls = ["http://localhost:9100/metrics"]
# 
#   ## Use SSL but skip chain & host verification
#   # insecure_skip_verify = false
#   ## Use bearer token for authorization
#   # bearer_token = /path/to/bearer/token
#}
{#
# # Reads last_run_summary.yaml file and converts to measurments
# [[inputs.puppetagent]]
#   ## Location of puppet last run summary file
#   location = "/var/lib/puppet/state/last_run_summary.yaml"
#}
{#
# # Read metrics from one or many RabbitMQ servers via the management API
# [[inputs.rabbitmq]]
#   url = "http://localhost:15672" # required
#   # name = "rmq-server-1" # optional tag
#   # username = "guest"
#   # password = "guest"
# 
#   ## A list of nodes to pull metrics about. If not specified, metrics for
#   ## all nodes are gathered.
#   # nodes = ["rabbit@node1", "rabbit@node2"]
#}
{#
# # Read raindrops stats (raindrops - real-time stats for preforking Rack servers)
# [[inputs.raindrops]]
#   ## An array of raindrops middleware URI to gather stats.
#   urls = ["http://localhost:8080/_raindrops"]
#}
{#
# # Read metrics from one or many redis servers
# [[inputs.redis]]
#   ## specify servers via a url matching:
#   ##  [protocol://][:password]@address[:port]
#   ##  e.g.
#   ##    tcp://localhost:6379
#   ##    tcp://:password@192.168.99.100
#   ##
#   ## If no servers are specified, then localhost is used as the host.
#   ## If no port is specified, 6379 is used
#   servers = ["tcp://localhost:6379"]
#}
{#
# # Read metrics from one or many RethinkDB servers
# [[inputs.rethinkdb]]
#   ## An array of URI to gather stats about. Specify an ip or hostname
#   ## with optional port add password. ie,
#   ##   rethinkdb://user:auth_key@10.10.3.30:28105,
#   ##   rethinkdb://10.10.3.33:18832,
#   ##   10.0.0.1:10000, etc.
#   servers = ["127.0.0.1:28015"]
#}
{#
# # Read metrics one or many Riak servers
# [[inputs.riak]]
#   # Specify a list of one or more riak http servers
#   servers = ["http://localhost:8098"]
#}
{#
# # Reads oids value from one or many snmp agents
# [[inputs.snmp]]
#   ## Use 'oids.txt' file to translate oids to names
#   ## To generate 'oids.txt' you need to run:
#   ##   snmptranslate -m all -Tz -On | sed -e 's/"//g' > /tmp/oids.txt
#   ## Or if you have an other MIB folder with custom MIBs
#   ##   snmptranslate -M /mycustommibfolder -Tz -On -m all | sed -e 's/"//g' > oids.txt
#   snmptranslate_file = "/tmp/oids.txt"
#   [[inputs.snmp.host]]
#     address = "192.168.2.2:161"
#     # SNMP community
#     community = "public" # default public
#     # SNMP version (1, 2 or 3)
#     # Version 3 not supported yet
#     version = 2 # default 2
#     # SNMP response timeout
#     timeout = 2.0 # default 2.0
#     # SNMP request retries
#     retries = 2 # default 2
#     # Which get/bulk do you want to collect for this host
#     collect = ["mybulk", "sysservices", "sysdescr"]
#     # Simple list of OIDs to get, in addition to "collect"
#     get_oids = []
# 
#   [[inputs.snmp.host]]
#     address = "192.168.2.3:161"
#     community = "public"
#     version = 2
#     timeout = 2.0
#     retries = 2
#     collect = ["mybulk"]
#     get_oids = [
#         "ifNumber",
#         ".1.3.6.1.2.1.1.3.0",
#     ]
# 
#   [[inputs.snmp.get]]
#     name = "ifnumber"
#     oid = "ifNumber"
# 
#   [[inputs.snmp.get]]
#     name = "interface_speed"
#     oid = "ifSpeed"
#     instance = "0"
# 
#   [[inputs.snmp.get]]
#     name = "sysuptime"
#     oid = ".1.3.6.1.2.1.1.3.0"
#     unit = "second"
# 
#   [[inputs.snmp.bulk]]
#     name = "mybulk"
#     max_repetition = 127
#     oid = ".1.3.6.1.2.1.1"
# 
#   [[inputs.snmp.bulk]]
#     name = "ifoutoctets"
#     max_repetition = 127
#     oid = "ifOutOctets"
# 
#   [[inputs.snmp.host]]
#     address = "192.168.2.13:161"
#     #address = "127.0.0.1:161"
#     community = "public"
#     version = 2
#     timeout = 2.0
#     retries = 2
#     #collect = ["mybulk", "sysservices", "sysdescr", "systype"]
#     collect = ["sysuptime" ]
#     [[inputs.snmp.host.table]]
#       name = "iftable3"
#       include_instances = ["enp5s0", "eth1"]
# 
#   # SNMP TABLEs
#   # table without mapping neither subtables
#   [[inputs.snmp.table]]
#     name = "iftable1"
#     oid = ".1.3.6.1.2.1.31.1.1.1"
# 
#   # table without mapping but with subtables
#   [[inputs.snmp.table]]
#     name = "iftable2"
#     oid = ".1.3.6.1.2.1.31.1.1.1"
#     sub_tables = [".1.3.6.1.2.1.2.2.1.13"]
# 
#   # table with mapping but without subtables
#   [[inputs.snmp.table]]
#     name = "iftable3"
#     oid = ".1.3.6.1.2.1.31.1.1.1"
#     # if empty. get all instances
#     mapping_table = ".1.3.6.1.2.1.31.1.1.1.1"
#     # if empty, get all subtables
# 
#   # table with both mapping and subtables
#   [[inputs.snmp.table]]
#     name = "iftable4"
#     oid = ".1.3.6.1.2.1.31.1.1.1"
#     # if empty get all instances
#     mapping_table = ".1.3.6.1.2.1.31.1.1.1.1"
#     # if empty get all subtables
#     # sub_tables could be not "real subtables"
#     sub_tables=[".1.3.6.1.2.1.2.2.1.13", "bytes_recv", "bytes_send"]
#}
{#
# # Read metrics from Microsoft SQL Server
# [[inputs.sqlserver]]
#   ## Specify instances to monitor with a list of connection strings.
#   ## All connection parameters are optional.
#   ## By default, the host is localhost, listening on default port, TCP 1433.
#   ##   for Windows, the user is the currently running AD user (SSO).
#   ##   See https://github.com/denisenkom/go-mssqldb for detailed connection
#   ##   parameters.
#   # servers = [
#   #  "Server=192.168.1.10;Port=1433;User Id=<user>;Password=<pw>;app name=telegraf;log=1;",
#   # ]
#}
{#
# # Inserts sine and cosine waves for demonstration purposes
# [[inputs.trig]]
#   ## Set the amplitude
#   amplitude = 10.0
#}
{#
# # Read Twemproxy stats data
# [[inputs.twemproxy]]
#   ## Twemproxy stats address and port (no scheme)
#   addr = "localhost:22222"
#   ## Monitor pool name
#   pools = ["redis_pool", "mc_pool"]
#}
{#
# # A plugin to collect stats from Varnish HTTP Cache
# [[inputs.varnish]]
#   ## The default location of the varnishstat binary can be overridden with:
#   binary = "/usr/bin/varnishstat"
# 
#   ## By default, telegraf gather stats for 3 metric points.
#   ## Setting stats will override the defaults shown below.
#   ## stats may also be set to ["all"], which will collect all stats
#   stats = ["MAIN.cache_hit", "MAIN.cache_miss", "MAIN.uptime"]
#}
{#
# # Read metrics of ZFS from arcstats, zfetchstats and vdev_cache_stats
# [[inputs.zfs]]
#   ## ZFS kstat path
#   ## If not specified, then default is:
#   kstatPath = "/proc/spl/kstat/zfs"
# 
#   ## By default, telegraf gather all zfs stats
#   ## If not specified, then default is:
#   kstatMetrics = ["arcstats", "zfetchstats", "vdev_cache_stats"]
# 
#   ## By default, don't gather zpool stats
#   poolMetrics = false
#}
{#
# # Reads 'mntr' stats from one or many zookeeper servers
# [[inputs.zookeeper]]
#   ## An array of address to gather stats about. Specify an ip or hostname
#   ## with port. ie localhost:2181, 10.0.0.1:2181, etc.
# 
#   ## If no servers are specified, then localhost is used as the host.
#   ## If no port is specified, 2181 is used
#   servers = [":2181"]
#}
{#

###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################
#}
{#
# # A Github Webhook Event collector
# [[inputs.github_webhooks]]
#   ## Address and port to host Webhook listener on
#   service_address = ":1618"
#}
{#
# # Read metrics from Kafka topic(s)
# [[inputs.kafka_consumer]]
#   ## topic(s) to consume
#   topics = ["telegraf"]
#   ## an array of Zookeeper connection strings
#   zookeeper_peers = ["localhost:2181"]
#   ## Zookeeper Chroot
#   zookeeper_chroot = "/"
#   ## the name of the consumer group
#   consumer_group = "telegraf_metrics_consumers"
#   ## Offset (must be either "oldest" or "newest")
#   offset = "oldest"
# 
#   ## Data format to consume.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#}
{#
# # Read metrics from MQTT topic(s)
# [[inputs.mqtt_consumer]]
#   servers = ["localhost:1883"]
#   ## MQTT QoS, must be 0, 1, or 2
#   qos = 0
# 
#   ## Topics to subscribe to
#   topics = [
#     "telegraf/host01/cpu",
#     "telegraf/+/mem",
#     "sensors/#",
#   ]
# 
#   # if true, messages that can't be delivered while the subscriber is offline
#   # will be delivered when it comes back (such as on service restart).
#   # NOTE: if true, client_id MUST be set
#   persistent_session = false
#   # If empty, a random client ID will be generated.
#   client_id = ""
# 
#   ## username and password to connect MQTT server.
#   # username = "telegraf"
#   # password = "metricsmetricsmetricsmetrics"
# 
#   ## Optional SSL Config
#   # ssl_ca = "/etc/telegraf/ca.pem"
#   # ssl_cert = "/etc/telegraf/cert.pem"
#   # ssl_key = "/etc/telegraf/key.pem"
#   ## Use SSL but skip chain & host verification
#   # insecure_skip_verify = false
# 
#   ## Data format to consume.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#}
{#
# # Read metrics from NATS subject(s)
# [[inputs.nats_consumer]]
#   ## urls of NATS servers
#   servers = ["nats://localhost:4222"]
#   ## Use Transport Layer Security
#   secure = false
#   ## subject(s) to consume
#   subjects = ["telegraf"]
#   ## name a queue group
#   queue_group = "telegraf_consumers"
# 
#   ## Data format to consume.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#}

{% if telegraf_config__inputs__statsd__enabled %}
[[inputs.statsd]]
  service_address          = "{{ telegraf_config__inputs__statsd__service_address }}"
  delete_gauges            = {{ telegraf_config__inputs__statsd__delete_gauges }}
  delete_counters          = {{ telegraf_config__inputs__statsd__delete_counters }}
  delete_sets              = {{ telegraf_config__inputs__statsd__delete_sets }}
  delete_timings           = {{ telegraf_config__inputs__statsd__delete_timings }}
  percentiles              = [{{ telegraf_config__inputs__statsd__percentiles|join(', ') }}]
  metric_separator         = "{{ telegraf_config__inputs__statsd__metric_separator }}"
  parse_data_dog_tags      = {{ telegraf_config__inputs__statsd__parse_data_dog_tags }}
{% if telegraf_config__inputs__statsd__templates|length %}
  templates                = [
{% for template in telegraf_config__inputs__statsd__templates %}
      "{{ template }}"{% if not loop.last %},{% endif %}
{% endfor %}
  ]
{% endif %}
  allowed_pending_messages = {{ telegraf_config__inputs__statsd__allowed_pending_messages }}
  percentile_limit         = {{ telegraf_config__inputs__statsd__percentile_limit }}
{% endif %}
{#
# # Stream a log file, like the tail -f command
# [[inputs.tail]]
#   ## files to tail.
#   ## These accept standard unix glob matching rules, but with the addition of
#   ## ** as a "super asterisk". ie:
#   ##   "/var/log/**.log"  -> recursively find all .log files in /var/log
#   ##   "/var/log/*/*.log" -> find all .log files with a parent dir in /var/log
#   ##   "/var/log/apache.log" -> just tail the apache log file
#   ##
#   ## See https://github.com/gobwas/glob for more examples
#   ##
#   files = ["/var/mymetrics.out"]
#   ## Read file from beginning.
#   from_beginning = false
# 
#   ## Data format to consume.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#}
{#
# # Generic TCP listener
# [[inputs.tcp_listener]]
#   ## Address and port to host TCP listener on
#   service_address = ":8094"
# 
#   ## Number of TCP messages allowed to queue up. Once filled, the
#   ## TCP listener will start dropping packets.
#   allowed_pending_messages = 10000
# 
#   ## Maximum number of concurrent TCP connections to allow
#   max_tcp_connections = 250
# 
#   ## Data format to consume.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#}
{#
# # Generic UDP listener
# [[inputs.udp_listener]]
#   ## Address and port to host UDP listener on
#   service_address = ":8092"
# 
#   ## Number of UDP messages allowed to queue up. Once filled, the
#   ## UDP listener will start dropping packets.
#   allowed_pending_messages = 10000
# 
#   ## Data format to consume.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#}